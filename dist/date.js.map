{"version":3,"file":"date.js","sources":["../src/date.ts"],"sourcesContent":["import validationError, {\n  type IValidationError,\n} from './utils/validation-error.ts';\n\ntype DateTimeFormatOptions = Parameters<typeof Intl.DateTimeFormat>[1];\n\ninterface IOptions {\n  allowBlank?: boolean;\n  before?: string | Date;\n  onOrBefore?: string | Date;\n  after?: string | Date;\n  onOrAfter?: string | Date;\n  format?: DateTimeFormatOptions;\n  errorFormat?: DateTimeFormatOptions;\n  locale?: string;\n}\n\n/**\n * @class Date\n * @module Validators\n */\n\n/**\n * @method validate\n * @param {String|Date} value\n * @param {Object} options\n * @param {Boolean} options.allowBlank If true, skips validation if the value is empty\n * @param {String|Date} options.before The specified date must be before this date\n * @param {String|Date} options.onOrBefore The specified date must be on or before this date\n * @param {String|Date} options.after The specified date must be after this date\n * @param {String|Date} options.onOrAfter The specified date must be on or after this date\n * @param {String} options.format Input value date format - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/DateTimeFormat\n *  - { dateStyle: 'long' } or { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }\n *  If you need to obtain precision (just compare years), use { year: 'numeric' }\n * @param {String} options.errorFormat Error output date format. Defaults to options.format or { dateStyle: 'long' }\n */\nexport default function validateDate(\n  value: number | string | Date,\n  options: IOptions,\n): true | IValidationError<number | string | Date, IOptions> {\n  const { locale = 'en-us', format, allowBlank } = options;\n  const { before, onOrBefore, after, onOrAfter } = options;\n\n  const errorFormat = options.errorFormat || format || { dateStyle: 'long' };\n\n  if ((allowBlank && value === null) || value === undefined || value === '') {\n    return true;\n  }\n\n  let date;\n\n  if (!value) {\n    if (format) {\n      date = new Intl.DateTimeFormat(locale, format).format(new Date());\n    }\n\n    date = new Date();\n  } else if (!isValidDate(new Date(value))) {\n    return validationError('date', value, options);\n  } else {\n    date = parseAsDate(value, format);\n  }\n\n  if (before) {\n    const beforeCompare = parseAsDate(before, format);\n\n    if (!isBefore(date, beforeCompare)) {\n      return validationError(\n        'before',\n        value,\n        Object.assign({}, options, {\n          before: parseDateError(beforeCompare, errorFormat, locale),\n        }),\n      );\n    }\n  }\n\n  if (onOrBefore) {\n    const onOrBeforeCompare = parseAsDate(onOrBefore, format);\n\n    if (!isSameOrBefore(date, onOrBeforeCompare)) {\n      return validationError(\n        'onOrBefore',\n        value,\n        Object.assign({}, options, {\n          onOrBefore: parseDateError(onOrBeforeCompare, errorFormat, locale),\n        }),\n      );\n    }\n  }\n\n  if (after) {\n    const afterCompare = parseAsDate(after, format);\n\n    if (!isAfter(date, afterCompare)) {\n      return validationError(\n        'after',\n        value,\n        Object.assign({}, options, {\n          after: parseDateError(afterCompare, errorFormat, locale),\n        }),\n      );\n    }\n  }\n\n  if (onOrAfter) {\n    const onOrAfterCompare = parseAsDate(onOrAfter, format);\n\n    if (!isSameOrAfter(date, onOrAfterCompare)) {\n      return validationError(\n        'onOrAfter',\n        value,\n        Object.assign({}, options, {\n          onOrAfter: parseDateError(onOrAfterCompare, errorFormat, locale),\n        }),\n      );\n    }\n  }\n\n  return true;\n}\n\n/**\n * This is a forcing function.  If `format` provided, date and comparison date will be in String format.  Otherwise, instances of Date.\n * I don't think there is a need to force iso8601 strings.\n * @function parseDate\n * @param {Date|String} date\n * @param {Object} format - { dateStyle: 'long' } or { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }\n * If you need to obtain precision (just compare years), use { year: 'numeric' }.\n * @param {String} locale\n * @returns {Date|String}\n */\nexport function parseDate(\n  date: string | number | Date,\n  format?: DateTimeFormatOptions,\n  locale?: string | string[],\n): string | Date {\n  if (format) {\n    // new Date(\"2015\") will give the last day in 2014.  This is problematic\n    const yearOnly = isYearFormat(format);\n\n    if (!(date instanceof Date)) {\n      // format date into string\n      // we have already checked this a valid date\n      const d = yearOnly ? new Date(date as number, 0) : new Date(date);\n      return new Intl.DateTimeFormat(locale, format).format(d);\n    }\n\n    // format date into string\n    const d = yearOnly ? new Date(date.getFullYear(), 0) : date;\n    return new Intl.DateTimeFormat(locale, format).format(d);\n  } else {\n    // Date constructor accepts a variety of formats including properly represented strings and Date instances.\n    // However, a variety of formats return an \"Invalid Date\" literal including DD/MM/YYYY\n    return new Date(date);\n  }\n}\n\nfunction parseDateError(\n  date: string | number | Date,\n  format?: DateTimeFormatOptions,\n  locale?: string | string[],\n) {\n  return parseDate(date, format, locale);\n}\n\nfunction parseAsDate(\n  date: string | number | Date,\n  format?: DateTimeFormatOptions,\n): Date {\n  if (format && isYearFormat(format)) {\n    return new Date(parseDate(date, format, 'en-us') as unknown as number, 0);\n  }\n  return new Date(parseDate(date, format, 'en-us'));\n}\n\nfunction isValidDate(d: unknown): boolean {\n  return d instanceof Date && !isNaN(d as unknown as number);\n}\n\nfunction isSame(date: Date, comp: Date): boolean {\n  return date.getTime() === comp.getTime();\n}\n\nfunction isBefore(date: Date, comp: Date): boolean {\n  return date < comp;\n}\n\nfunction isAfter(date: Date, comp: Date): boolean {\n  return date > comp;\n}\n\nfunction isSameOrAfter(date: Date, comp: Date): boolean {\n  return isSame(date, comp) || isAfter(date, comp);\n}\n\nfunction isSameOrBefore(date: Date, comp: Date): boolean {\n  return isSame(date, comp) || isBefore(date, comp);\n}\n\nfunction isYearFormat(format: object): format is { year: string } {\n  return Object.keys(format).length === 1 && 'year' in format;\n}\n"],"names":["validateDate","value","options","locale","format","allowBlank","before","onOrBefore","after","onOrAfter","errorFormat","dateStyle","undefined","date","Intl","DateTimeFormat","Date","isValidDate","validationError","parseAsDate","beforeCompare","isBefore","Object","assign","parseDateError","onOrBeforeCompare","isSameOrBefore","afterCompare","isAfter","onOrAfterCompare","isSameOrAfter","parseDate","yearOnly","isYearFormat","d","getFullYear","isNaN","isSame","comp","getTime","keys","length"],"mappings":"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"}